import { AxiosInstance } from 'axios';
import { Filter, FrappeDoc, GetDocListArgs, GetLastDocArgs } from './types';
export declare class FrappeDB {
    /** URL of the Frappe App instance */
    private readonly appURL;
    /** Axios instance */
    readonly axios: AxiosInstance;
    /** Whether to use the token based auth */
    readonly useToken: boolean;
    /** Token to be used for authentication */
    readonly token?: () => string;
    /** Type of token to be used for authentication */
    readonly tokenType?: 'Bearer' | 'token';
    constructor(appURL: string, axios: AxiosInstance, useToken?: boolean, token?: () => string, tokenType?: 'Bearer' | 'token');
    /**
     * Get a document from the database
     * @param {string} doctype Name of the doctype
     * @param {string} docname Name of the document
     * @returns Promise which resolves to the document object
     */
    getDoc<T = any>(doctype: string, docname?: string): Promise<FrappeDoc<T>>;
    /**
     * Gets a list of documents from the database for a particular doctype. Add filters, sorting order and pagination to get a filtered and sorted list of documents.
     * @param {string} doctype Name of the doctype
     * @param {@type GetDocListArgs} [args] Arguments for the query
     * @returns Promise which resolves to an array of documents
     */
    getDocList<T = any, K = FrappeDoc<T>>(doctype: string, args?: GetDocListArgs<K>): Promise<T[]>;
    /** Creates a new document in the database
     * @param {string} doctype Name of the doctype
     * @param {Object} value Contents of the document
     * @returns Promise which resolves with the complete document object
     */
    createDoc<T = any>(doctype: string, value: T): Promise<FrappeDoc<T>>;
    /** Updates a document in the database
     * @param {string} doctype Name of the doctype
     * @param {string} docname Name of the document
     * @param {Object} value Contents of the document to update (only the fields that are to be updated)
     * @returns Promise which resolves with the complete document object
     */
    updateDoc<T = any>(doctype: string, docname: string | null, value: Partial<T>): Promise<FrappeDoc<T>>;
    /**
     * Deletes a document in the database
     * @param {string} doctype Name of the doctype
     * @param {string} docname Name of the document
     * @returns Promise which resolves an object with a message "ok"
     */
    deleteDoc(doctype: string, docname?: string | null): Promise<{
        message: string;
    }>;
    /**
     * Gets count of documents from the database for a particular doctype with the given filters
     * @param {string} doctype Name of the doctype
     * @param {@type Filter[]} [filters] Filters to be applied in the count query
     * @param {boolean} [cache] Whether to cache the result or not
     * @param {boolean} [debug] Whether to print debug messages or not
     * @returns Promise which resolves a number
     */
    getCount<T = any>(doctype: string, filters?: Filter<T>[], cache?: boolean, debug?: boolean): Promise<number>;
    /**
     * Get a document from the database
     * @param {string} doctype Name of the doctype
     * @param {@type GetLastDocArgs} [args] Arguments for the query
     * @returns Promise which resolves to the document object
     */
    getLastDoc<T = any>(doctype: string, args?: GetLastDocArgs<FrappeDoc<T>>): Promise<FrappeDoc<T>>;
}
